=== common rules (applies to all files) ===

lines must wrap at 72 columns on every file meant to be manually read
and updated on a regular basis, but could extend longer on files
generated by scripts.

provided text and comments, excluding names of all kinds, must be
written in lowercase.

indentation must use spaces, and must occur at multiples of 4 spaces.

such indentation must be kept in empty lines whenever the surrounding
lines are indented to the same level.

file names must be written in lowercase, and must separate words using
dashes.

=== including headers (applies to "*.h" and "*.c" files) ===

in both headers and source files, headers must be included in ascending
lexicographical order, with the sole exception that, in source files
that are directly associated with headers, they must include them in a
separate paragraph that precedes all included headers.

for example, given a file named "foo.c" that implements a header named
"foo.h", headers may be included as follows:

>   #include <foo.h>
>   
>   #include <a-header-name.h>
>   #include <bar.h>
>   #include <interval/kernel/page.h>

=== writing headers (applies to "*.h" files) ===

headers must use their full path written in uppercase with all
non-alphanumeric characters replaced with underscores as guards.

for example, given a file whose full path is "foo/bar-1.00/tee.h", the
guard may be defined as follows:

>   #ifndef __FOO_BAR_1_00_TEE_H__
>   #define __FOO_BAR_1_00_TEE_H__
>   
>   (...)
>   
>   #endif

non-local functions and symbols must be declared first in headers, but
local ones must not be declared anywhere (they should appear first in
source files or as inline functions in headers).

=== grouping lines (applies to "*.h" and "*.c" files) ===

blocks must be isolated with empty lines, with the only exception being
trailing blocks (i.e. if-else, do-while, and such).

individual lines may be grouped together in any amount depending on the
context, but groups of 1 or 2 lines are usually preferred.

individually prefixed lines (i.e. if, while, for, and such) must be
written on the same line.

=== naming types and symbols (applies to "*.h" files) ===

functions and symbols must be written in lowercase, with underscores as
word dividers.

types must be written following the same conventions as functions and
symbols, and must be suffixed with "_t" (like "size_t").

types and symbols belonging to a main module must be prefixed with a
single lowercase letter representing the module, followed by an
underscore. for example, given a main module named "foo", a valid type
name would be "f_thing_t".

types and symbols belonging to a platform module must be prefixed with
the full module name written in lowercase, followed by an underscore.
for example, given a platform named "bar-1.00", a valid function name
would be "bar_1_00_do_something()".

local functions, symbols and types must not be prefixed (note that this
is not just a recommendation).

cross-module macros must be written following the same conventions as
functions and symbols. local macros and preprocessor constants must be
written in uppercase.

=== placing braces (applies to "*.h" and "*.c" files) ===

opening braces must be placed on the line they logically belong to, for
example:

>   void bar_1_00_do_something(void) {
>       if (true) {
>           // do something.
>       } else {
>           // what?
>       }
>   }

when trailing blocks are present (i.e. if-else, do-while and such),
closing braces must be placed on the line such blocks logically belong
to.

braces must not be internally padded but must be externally padded, as
follows:

>   // this is NOT allowed (is not externally padded):
>   f_thing_t x = (f_thing_t){.a = 1, .b = 2};
>   
>   // this is NOT allowed (is internally padded):
>   f_thing_t y = (f_thing_t) { .a = 1, .b = 2 };
>   
>   // this is allowed:
>   f_thing_t z = (f_thing_t) {.a = 1, .b = 2};

=== placing parentheses/brackets (applies to "*.h" and "*.c" files) ===

parentheses and brackets must not be internally padded and should only
be externally padded on prefixed lines (i.e. if, while, for, and such).

parentheses must surround the expression during any cast. unary
operators (i.e. "-", "&", "*", "!") must also surround the expression
with parentheses, as follows:

>   // this is NOT allowed:
>   long a = *p;
>   
>   // this is allowed:
>   long b = *(p);
>   
>   // this is NOT allowed:
>   char c = *(char *)(p);
>   
>   // this is allowed:
>   char d = *((char *)(p));

=== declaring functions (applies to "*.h" and "*.c" files) ===

when declaring functions, C23-style attributes (i.e. "[[unsequenced]]")
must be used in all applicable cases. furthermore, the attributes
"[[deprecated]]" and "[[nodiscard]]" must provide sensible messages.

unused arguments are allowed not to be named, but functions with no
arguments must explicitly state so, as follows:

>   // this is NOT allowed: 
>   long random_1();
>   
>   // this is allowed:
>   long random_2(void);
>   
>   // this is allowed:
>   long random_3(bool, char, char);
>   
>   // this is (obviously) allowed:
>   long random_4(bool do_keep_seed);

=== selecting types (applies to "*.h" and "*.c" files) ===

when an integer type with sign is desired, "long" must be used instead
of "int" and other alternative types. if that type is known to be
constrained to small values, "signed char" is allowed to be used but is
not required.

when an unsigned integer type that should hold counts and sizes is
desired, "size_t" must be used and "stddef.h" needs to be included.

when an unsigned integer type that should hold an exact byte and that
should be byte-aligned is desired, "unsigned char" must be used instead
of "uint8_t" and other alternative types.

when an integer type that should hold a UTF-8 character byte and that
should be byte-aligned is desired, "char" must be used; however, when
parsing UTF-8 bytes individually, it may be helpful to cast individual
characters to "unsigned char" (this should be done at the latest point
possible).

when an unsigned integer type that should hold an exact amount of bytes
other than 1 and that should be aligned is desired, "uint??_t" must be
used and "stdint.h" needs to be included (this should be done at the
latest point possible).

the boolean type "bool" must be used instead of integer types alongside
boolean constants like "true" and "false".

the floating-point type "double" is the only allowed non-integer
numerical type.

when declaring pointers, the asterisk must be padded.

for pointers, "nullptr" must be used over "NULL" as null pointer
constants and, when performing null checking in generics, "nullptr_t"
should be used and "stddef.h" needs to be included.

=== semantically naming rules (applies to "*.h" and "*.c" files) ===

boolean symbols and functions returning booleans must, ignoring their
prefix, start with "do_", "is_" or "with_".

functions that change the state of the program, a local symbol or a
referenced structure must use verbs in infinitive form (like
"date_increment"). functions that return a property of such state
without changing it must use the name of the property (for example,
"date_weekday"). functions that convert values must, ignoring their
prefix, have a name either of the form "??_to_??" or the form "to_??".

when dealing with bounded memory areas, names must end with:

-   "_list" (if the symbol is a list of typed elements whose number is
    to be suffixed with "_n").

-   "_buffer" (when dealing with small memory areas or strings whose
    size is to be suffixed with "_size" or "_length", the latter if it
    is a string).

-   "_region" (when dealing with large memory areas whose size is to be
    suffixed with "_size" if in bytes, or with "_n" if in pages).

functions and symbols with long names that have several numbered
versions must start on 1 and must suffix its number.

symbols with single-letter names must be named from the following sets:

-   a/b/c/d/e/f (when multiple symbols of the same non-trivial type are
    used; note that the only letters that are allowed to be used
    individually are "c" for characters and "f" for function pointers).

-   i/j/k/l (when indexing elements of lists, structures or anything
    else).

-   n (element counts).

-   o (byte/page offsets into memory areas).

-   p/q/r/s (pointers to arbitrary memory areas).

-   u/v (they serve the same purpose as a/b/c/d/e/f, though they must
    not be mixed together; if both refer to childrens of a binary tree
    node, "w" may be used to refer to their parent).

-   x/y/z (when multiple symbols of the same numeric type are used; as
    with a/b/c/d/e/f, only "z" is allowed to be used individually for
    numeric types).

=== padding and choosing operators (applies to "*.c" files) ===

all binary (as in having 2 arguments) operators must be padded.

boolean, bitwise and shifting expressions must be always enclosed in
parentheses.

on boolean expressions, the preferred comparison operators are ">=",
"==", "<" and "!=".

when having a series of additions and subtractions, all additions must
come first, and subtractions must not be grouped into a single one.

finally, parentheses should be minimized (except with divisions), and
complex expressions must come after simpler expressions.
